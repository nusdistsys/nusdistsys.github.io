<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Atomic | 6.824 DYOM</title><link rel=canonical href=https://nusdistsys.github.io/notes/atomic/><link rel=stylesheet href=https://nusdistsys.github.io/css/base.css integrity crossorigin=anonymous></head><body><nav><div class="px-2 bg-teal-700 fixed w-full"><ul class="flex h-full list-none m-0"><li class=p-4><a class="inline font-medium text-xl text-white" href=https://nusdistsys.github.io/>6.824 DYOM</a></li><li class="flex hover:bg-teal-800 h-full content-center p-4"><a class="inline font-light text-xl text-white" href=https://nusdistsys.github.io/labs/>Labs</a></li><li class="flex hover:bg-teal-800 h-full content-center p-4"><a class="inline font-light text-xl text-white" href=https://nusdistsys.github.io/notes/>Notes</a></li><li class="flex hover:bg-teal-800 h-full content-center p-4"><a class="inline font-light text-xl text-white" href=https://nusdistsys.github.io/summer/>Summer</a></li></ul></div></div></nav><main><div class="container max-w-3xl mx-auto pt-20"><article><header><span class="block py-8"><h1><a class=font-sans href=https://nusdistsys.github.io/notes/atomic/ rel=bookmark>Atomic</a></h1><time datetime=2020-04-14T12:18:54+08:00>14 April, 2020</time></span></header><h1 id=atomic>Atomic</h1><pre><code>Goal: define atomicity and describe strategies on how it can be achieved
</code></pre><p>Property required in several different areas of computer system design.</p><p>There are two main kinds of atomicity, but different sources of literature might define these things differently.</p><p><code>All-or-nothing</code> is regarded as the default definition of atomicity.</p><p><code>Before-or-after</code> is sometimes regarded as <em>Isolation</em>.</p><p>There remain some important gaps in our exploration of atomicity. First, in a <strong>layered system</strong>, a transaction implemented in one layer may consist of a series of component actions of a lower layer that are themselves atomic. The question is how the commitment of the lower-layer transactions should relate to the commitment of the higher layer trans­ action. If the higher-layer transaction decides to abort, the question is what to do about lower-layer transactions that may have already committed. There are two possibilities:
• Reverse the effect of any committed lower-layer transactions with an UNDO action. This technique requires that the results of the lower-layer transactions be visible only within the higher-layer transaction.
• Somehow delay commitment of the lower-layer transactions and arrange that they actually commit at the same time that the higher-layer transaction commits.</p><h2 id=all-or-nothing-atomicity>All-or-nothing Atomicity</h2><pre><code>A sequence of steps is an all-or-nothing action if, from the point of view of its invoker, the sequence always either
- completes, or
- aborts in such a way that it appears that the sequence had never been undertaken in the first place. That is, it backs out.
</code></pre><h3 id=techniques>Techniques:</h3><p>This layer implements what is known as <em>journal storage</em>. The basic idea of journal storage is straightforward: we associate with every named variable not a single cell, but a list of cells in non-volatile storage; the values in the list represent the history of the variable.</p><h2 id=before-or-after-atomicity>Before-or-after Atomicity</h2><pre><code>Concurrent actions have the before-or-after property if their effect from the point of view of their invokers is the same as if the actions occurred either completely before or completely after one another.
</code></pre><p>Several actions that concurrently operate on the same data should not interfere with one another.</p><h3 id=techniques-1>Techniques:</h3><ol><li>System-wide lock</li></ol><p>Anytime any shared resource is needed, acquire a</p><ol start=2><li>Fine-grained locks
needed locks at begin_transaction and release all of them at end_transaction</li></ol><ul><li><p>advantage: easy to reason about. works great if it could be implemented</p></li><li><p>disadvantage: requires transaction to know all of its needed locks in advance</p></li></ul><ol start=3><li>Two phase locking</li></ol><p>Gradually acquire locks as you need them (phase 1). Primary constraint is that the transaction may not release any locks until it passes its lock point.(phase 2) Further, the transaction can release a lock on an object that it only reads any time after it reaches its lock point if it will never need to read that object again, even to abort.</p><p>The name of the discipline comes about because the number of locks acquired by a transaction monotonically increases up to the lock point (the first phase), after which it monotonically decreases (the second phase).</p><p>Informally, once a transaction has acquired a lock on a data object, the value of that object is the same as it will be when the transaction reaches its lock point, so reading that value now must yield the same result as waiting till then to read it. Furthermore, releasing a lock on an object that it hasn’t modified must be harm­less if this transaction will never look at the object again, even to abort.</p><h2 id=distributed-two-phase-commits>Distributed Two-phase commits</h2><p>TLDR:</p><p>Distributed version of a two phase commit protocol. Difference is that coordinator and workers cannot reliably communicate, thus reduces to constructing a reliable distributed version of two-phase commit protocol using persistent senders and duplicate suppression.</p></article></div></main></body></html>