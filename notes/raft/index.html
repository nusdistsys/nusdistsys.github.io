<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Raft | 6.824 DYOM</title><link rel=canonical href=https://nusdistsys.github.io/notes/raft/><link rel=stylesheet href=https://nusdistsys.github.io/css/base.css integrity crossorigin=anonymous></head><body><nav><div class="px-2 bg-teal-700 fixed w-full"><ul class="flex h-full list-none m-0"><li class=p-4><a class="inline font-medium text-xl text-white" href=https://nusdistsys.github.io/>6.824 DYOM</a></li><li class="flex hover:bg-teal-800 h-full content-center p-4"><a class="inline font-light text-xl text-white" href=https://nusdistsys.github.io/labs/>Labs</a></li><li class="flex hover:bg-teal-800 h-full content-center p-4"><a class="inline font-light text-xl text-white" href=https://nusdistsys.github.io/notes/>Notes</a></li></ul></div></div></nav><main><div class="container max-w-3xl mx-auto pt-20"><article><header><span class="block py-8"><h1><a class=font-sans href=https://nusdistsys.github.io/notes/raft/ rel=bookmark>Raft</a></h1><time datetime=2020-01-28T17:25:09+08:00>28 January, 2020</time></span></header><h1 id=raft>Raft</h1><h2 id=summary>Summary</h2><p>A consensus algorithm that is usually used to keep replicated logs consistent. Created to be easier to understand (than Paxos).
Replicated logs can be used to implement replicated state machines, e.g. distribtued databases.
Since state machines are deterministic, feeding them the same instructions lead to the same output, hence keeping the log consistent is important.</p><p>Raft:</p><ul><li>can tolerate non-byzantine failures e.g. partitions, fail-stop servers, lost/delayed messages</li><li>does not depend on timing</li><li>in general, works as long as a majority of servers are up</li></ul><p>A raft cluster contains several servers, each server is a Follower, Candidate or Leader.
In normal operation, for a given term, there is only one leader.</p><p>Raft defines two RPCS: AppendEntries (AE) and RequestVotes (RV), which are used for the following operations:</p><h2 id=leader-election>Leader election</h2><ul><li>Leader establishes &ldquo;leadership&rdquo; for this term by periodically sending out heartbeats (empty AEs) to other nodes</li><li>If a Follower doesn't receive a heartbeat for too long, it becomes a candidate, triggers election for term + 1.</li><li>Candidate tries to gather votes from other nodes by RV: other nodes will respond yes if the candidate has a equal or higher term and have not yet voted for this term, and Candidate's log is up-to-date</li><li>If Candidate gathers majority, it becomes leader, and begins sending out hearbeats for term + 1. Else remain candidate.</li><li>If the Leader is partitioned, some other Follower will eventually transition to Candidate.</li><li>If a Follower(s) is partitioned, as along as a majority are up, they will be able to elect a Leader anyways.</li><li>How to depose old Leader/loser Candidates? They will resign and become Followers once they receive heartbeats from the new Leader.</li></ul><p>All commands from clients are issued to the Leader, then replicated to followers. (Another property that makes Raft easier to understand: log entries flow in only one direction.)</p><h2 id=log-replication>Log replication</h2><ul><li>Once a leader is elected, it services all client requests (leader-based approach). Commands from clients are recorded as logs in Leader, then replicated via AE to other nodes.</li><li>Logs are committed (= safe to apply) once the leader in the same term has replicated it to a majority of servers</li><li>Leader's commitIndex is known to other nodes via AE, so that they know when its safe to apply logs. The Leader also keeps track of which log the others have replicated up-to.</li><li>Log entries replicated via AE may be lost by Follower crashes, Leader crashes</li><li>Raft maintains Log Matching Property (refer to paper)</li><li>Consistency check in AE guarantees that the log preceeding the one to be appended matches. If they don't match, leader re-replicates old logs to server.</li><li>Inconsistent logs are resolved by forcing Followers to duplicate Leader's log (leader-based approach). Old logs might be overwritten by new Leaders (refer to tutorial)</li></ul><h2 id=potential-issues>Potential issues</h2><ul><li>Heartbeat timeout too high, election timeout too low: will cause unnecessary leadership changes</li><li>Multiple elections with split votes (no majority). Election timeouts should be random to prevent this.</li><li>Where nodes are far apart, election timeouts must be large enough</li></ul><h2 id=comparision-with-paxos>Comparision with Paxos</h2><table><thead><tr><th>Raft</th><th>Paxos</th></tr></thead><tbody><tr><td>Leader-based</td><td>Peer-to-peer communication (but a leader is usually chosen anyways)</td></tr><tr><td>Easy to understand</td><td>Hard-to-understand, implement</td></tr></tbody></table><h2 id=questions>Questions</h2><ul><li>Paper says &ldquo;Raft implements linearizable semantics&rdquo; == Raft supports strongly consistent?</li><li>Q: Performance differences with Paxos? (I got no numbers)<ul><li>A: Not really once a leader is elected</li></ul></li></ul></article></div></main></body></html>